# 通用开发工作流程规范

> 本文档是面向 Claude 与开发者共同遵守的项目开发流程规范模板。
> 在具体项目中，通过 CLAUDE.md 引用本文档：`@docs/workflow.md`

---

## 1. Claude 行为准则

### 1.1 核心原则

- **先规划后动手**：收到任务后，先说明理解和执行计划，等用户确认后再开始实现
- **单步推进**：每次只完成一个明确的步骤（一个模块、一个函数、一组相关修改），完成后停下等待反馈
- **最小变更**：不做未被要求的重构、不引入未讨论过的依赖、不改动无关文件
- **设计先于代码**：涉及新功能或架构变更时，必须先产出或更新设计文档，经确认后才可编码
- **诚实报告**：遇到不确定的问题、发现设计文档中的矛盾或遗漏时，立即向用户说明，不自行假设或绕过

### 1.2 操作禁令

- **禁止**为了让测试通过而修改测试用例（除非确认是用例本身的错误）
- **禁止**在未读设计文档的情况下开始编码实现
- **禁止**一次性提交跨多个模块的大规模变更
- **禁止**在设计阶段未确认时擅自推进到实现阶段
- **禁止**删除或注释掉失败的测试用例

---

## 2. 设计阶段流程

新增核心功能时，按以下三个阶段推进设计。每个阶段产出设计文档，经用户确认后再进入下一阶段。

### 2.1 调研阶段

目标：充分了解问题域，避免重复造轮子或遗漏关键方案。

产出调研报告，内容包括：
1. 梳理本项目已有的相关基础设施和能力
2. 调研外部现有实现和学术文献，梳理算法变体、已知优化、适用场景
3. 对比各方案的优劣和适用条件
4. 给出推荐方案及理由

### 2.2 架构阶段

目标：确定整体结构，定义模块边界和交互契约。

产出架构文档，内容包括：
1. 核心流程描述（数据从输入到输出的完整路径）
2. 模块划分及各模块的**功能规约**（见§3 规约书写规范）
3. 模块间的**接口规约**（数据如何流转、调用关系）
4. 关键设计决策及其理由

### 2.3 细化阶段

目标：将架构落实为可直接编码的函数级设计。

产出细化文档，内容包括：
1. 逐模块列出需要实现的函数：函数签名、功能描述、调用关系
2. 与已有代码的复用点
3. 错误处理策略

**约束**：细化不得改变架构阶段确定的模块划分、接口规约和核心流程。如需变更须回到架构阶段重新讨论。

### 2.4 设计文档审查

设计完成后，进入实现前必须通过审查：
1. 架构设计能够实现原定目标，正确性有保证
2. 细化阶段每个模块的函数设计满足该模块的功能规约和接口规约
3. 文档无歧义，可直接用于开发实现

---

## 3. 规约书写规范

设计文档中的规约采用半形式化风格书写，兼顾精确性和可读性。

### 3.1 功能规约格式

每个模块或关键函数的规约包含以下要素：

```
函数/模块名称：<名称>

功能描述：<一句话概述做什么>

前置条件（Requires）：
  - <调用前必须满足的条件，用自然语言 + 数学表达式>

后置条件（Ensures）：
  - <调用后保证成立的性质>

不变式（Invariants）：（如适用）
  - <执行过程中始终保持的性质>

副作用：<无 / 修改了哪些状态>
```

### 3.2 接口规约格式

模块间的接口规约描述数据流转契约：

```
接口：<模块A> → <模块B>

输入数据：<类型和语义描述>
输出数据：<类型和语义描述>

协议约定：
  - <调用方的责任（保证输入满足什么条件）>
  - <被调用方的责任（保证输出满足什么条件）>
```

### 3.3 并发规约格式（可选）

涉及多线程/并行计算的模块，须额外补充并发规约。不涉及并发的项目可跳过本节。

```
并发单元：<函数/模块名称>

共享资源：
  - <资源名称>：<类型和语义描述>

锁协议（Locking Protocol）：
  - <获取和释放顺序，如：先获取 lock_A 再获取 lock_B，禁止反序>
  - <锁粒度说明：粗粒度/细粒度/读写锁>

顺序约束（Ordering Constraints）：
  - <操作间的先后关系，如：write(X) must happen-before read(X)>
  - <内存序要求（如适用）：acquire/release/seq_cst>

Rely-Guarantee 条件：（如适用）
  - Rely（环境承诺）：<其他线程保证不做什么 / 保持什么性质>
  - Guarantee（自身承诺）：<本线程保证对共享状态做什么 / 不做什么>

线程安全性结论：
  - <该模块/函数是否线程安全，在什么条件下安全>
```

**使用时机**：在架构阶段识别并发边界，在细化阶段为每个涉及共享状态的函数补充并发规约。

### 3.4 书写原则

- 条件描述优先用数学表达式（如 `n ≥ 0`、`deg(f) < deg(g)`），辅以自然语言解释
- 避免模糊用词（"合理的"、"适当的"），所有约束必须可判定
- 对于复杂算法，可附伪代码辅助说明，但规约本身必须独立于实现细节

---

## 4. 实现阶段流程

严格按照设计文档分模块实现，按设计文档中的模块顺序依次推进。

### 4.1 逐模块推进

每个模块的开发流程：
1. 阅读该模块的设计文档（功能规约、接口规约、函数设计）
2. 编码实现
3. 编写测试并运行
4. 代码审核
5. 审核通过后进入下一模块

### 4.2 代码审核

审核内容：
- **一致性**：实现与设计文档的接口、功能、调用关系是否匹配
- **风格**：与项目现有代码保持一致
- **正确性**：是否存在 CWE 类缺陷、逻辑错误、冗余代码
- **性能**：是否存在不必要的拷贝、重复计算等性能冗余点
- **可维护性**：模块边界是否清晰，是否有功能错位（应归并或移到其他模块的代码）

### 4.3 代码测试分层

1. **基本功能测试** — 按设计文档编写用例，验证主体功能正确性（函数→模块→整体逐层覆盖）
2. **边缘情况测试** — 覆盖边界条件和特殊输入
3. **随机测试** — 随机生成足够广泛的用例，条件允许时与参考实现交叉验证

### 4.4 测试失败处理

测试不通过时，**禁止盲目修改测试用例使其通过**。必须先分析原因：
- **测试用例编写错误** — 修正用例，说明修正理由
- **被测试对象 bug** — 保留原测试用例和复现用例，在测试报告中记录 bug，不绕过
- **缺少 API 导致使用不便** — 在测试报告中记录，作为后续改进项

---

## 5. 修复与迭代流程

当发现 bug 或需要补充功能时：

1. **列出问题清单** — 明确需要修正的 bug 和补充的功能
2. **分类处理**：
   - **显而易见的错误**（笔误、off-by-one 等局部问题）— 直接修复，补充测试用例
   - **算法内部逻辑错误**（实现偏离正确算法、边界处理遗漏等）— 完成根因分析并产出修正方案文档（§5.1），经确认后直接修复
   - **接口或架构层面问题**（接口不合理、模块划分缺陷、新增功能）— 先完成根因分析（§5.1），再回到设计阶段（§2）调整设计文档，最后按实现流程执行
3. **举一反三** — 梳理是否存在其他同类问题，反思问题产生的原因，补充相关测试用例
4. **回归测试** — 将本次发现 bug 的用例补充为回归用例，重新运行所有已有模块的测试，确保无回归

### 5.1 根因分析与修正方案文档（修复前必做）

对于非显而易见的错误，**禁止**跳过分析直接编码修复。必须先产出**修正方案文档**（`docs/fixes/<模块名>-fix-<简述>.md`），经用户确认后才可编码。

文档包含以下四部分：

#### 第一部分：复现与定位

- 最小复现用例（可直接编译运行）
- 出错的代码路径（文件名、行号、调用链）
- 预期行为 vs 实际行为

#### 第二部分：根因分析

- 区分"症状"和"根因"
- 如果修复方案是绕过而非消除根因，必须明确标注

#### 第三部分：参考实现对照（算法类 bug 必做）

- 对照 CLAUDE.md 中列出的参考实现（至少一个）
- 用同一组输入数据，逐步对比我们的实现与参考实现在出错路径上的**具体执行差异**
- 确认差异点即为根因

#### 第四部分：修正方案

- 修什么（具体到函数、行号）
- 为什么这样修（根因如何被消除）
- 参考实现是怎么做的（附代码片段或伪代码）
- 修改后的预期行为（用第一部分的复现用例走一遍修正后的逻辑）

**反模式警示**：
- **禁止**未对照参考实现就提出算法修正方案（避免基于错误理解的"修复"引入新问题）
- **禁止**用 workaround 替代根因修复而不加说明（如：加主变量轮换来绕过 LC 匹配 bug，本身有价值，但不能替代修复匹配算法本身）
- 如果连续出现 3 个以上针对同一模块的 patch，必须停下来重新做根因分析，检查是否在治标不治本

---

## 6. 文档管理

### 6.1 目录结构

```
docs/
├── research/          # 调研报告
│   └── <功能名>-research.md
├── design/            # 架构文档与细化文档
│   └── <功能名>/
│       ├── architecture.md
│       └── detailed-design.md
├── fixes/             # 修正方案文档
│   └── <模块名>-fix-<简述>.md
├── test-reports/      # 测试报告与 bug 记录
│   └── <功能名>-test-report.md
└── workflow.md        # 本文档
```

### 6.2 文档版本控制

- 设计文档随代码一起纳入 Git 管理
- 设计文档的修改须在 commit message 中注明原因（如 `docs: 更新 XXX 模块接口规约，适配 YYY 变更`）
- 文档过大时拆分为多个文件，在主文档中用目录索引

### 6.3 文档演进原则

- 实现过程中发现设计文档有误或不足，**先更新文档再改代码**，保持文档与代码同步
- 每轮迭代结束后检查文档是否仍然准确反映当前实现
- 废弃的设计决策不删除，标注 `[已废弃]` 并说明替代方案和原因

---

## 7. 流程速查

```
新功能开发：
  调研 → [确认] → 架构 → [确认] → 细化 → [确认] → 审查 → 逐模块实现+测试+审核

Bug 修复：
  局部错误     → 直接修复 + 补测试 + 回归
  算法内部错误 → 修正方案文档(§5.1) → [确认] → 修复 + 补测试 + 回归
                 ↑ 算法类 bug 必须对照参考实现
  接口/架构问题 → 修正方案文档(§5.1) → [确认] → 更新设计(§2) → 按实现流程执行 + 回归

Claude 每步操作：
  说明计划 → [等待确认] → 执行单步 → 报告结果 → [等待反馈]
```
